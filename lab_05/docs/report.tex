\documentclass{bmstu}

\usepackage{biblatex}
\usepackage{array}
\usepackage{amsmath}

\addbibresource{inc/biblio/sources.bib}

\begin{document}

\makereporttitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {лабораторной работе №~5}
    {Защита информации}
    {Программная реализация алгоритма Хаффмана для сжатия данных}
    {2}
    {Марченко~В./ИУ7-73Б}
    {Чиж~И.~С.}

{\centering \maketableofcontents}

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Алгоритм Хаффмана --- жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью. 
Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы. 
В настоящее время используется во многих программах сжатия данных~\cite{HuffmanCode}.

Целью данной лабораторной работы является программная реализация алгоритма Хаффмана для сжатия данных.

Задачи лабораторной работы:
\begin{enumerate}
\item[1)] изучить принцип работы алгоритма Хаффмана;
\item[2)] разработать программное обеспечение для сжатия и восстановления файлов с помощью алгоритма Хаффмана;
\item[3)] протестировать разработанное программное обеспечение.
\end{enumerate}

\chapter{Алгоритм Хаффмана}

Идея алгоритма состоит в следующем: зная вероятности появления символов в сообщении, можно описать процедуру построения кодов переменной длины, состоящих из целого количества битов. 
Символам с большей вероятностью ставятся в соответствие более короткие коды. 
Коды Хаффмана обладают свойством префиксности (то есть ни одно кодовое слово не является префиксом другого), что позволяет однозначно их декодировать.

Классический алгоритм Хаффмана на входе получает таблицу частотностей символов в сообщении. 
Далее на основании этой таблицы строится дерево кодирования Хаффмана (Н-дерево) по следующему алгоритму.
\begin{enumerate}
\item Символы входного алфавита образуют список свободных узлов. 
Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
\item Выбираются два свободных узла дерева с наименьшими весами.
\item Создается их родитель с весом, равным их суммарному весу.
\item Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.
\item Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой --- бит 0. 
Битовые значения ветвей, исходящих от корня, не зависят от весов потомков.
\item Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. 
Он и будет считаться корнем дерева.
\end{enumerate}

Допустим, у есть следующая таблица абсолютных частотностей: А --- 15 раз, Б --- 7 раз, В --- 6 раз, Г --- 6 раз и Д --- 5 раз. 
Этот процесс можно представить как построение дерева, корень которого --- символ с суммой вероятностей объединенных символов, получившийся при объединении символов из последнего шага, его $n_0$ потомков --- символы из предыдущего шага и т.~д.

Чтобы определить код для каждого из символов, входящих в сообщение, нужно пройти путь от листа дерева, соответствующего текущему символу, до его корня, накапливая биты при перемещении по ветвям дерева (первая ветвь в пути соответствует младшему биту). 
Полученная таким образом последовательность битов является кодом данного символа, записанным в обратном порядке.

Для данной таблицы символов коды Хаффмана будут выглядеть следующим образом: А --- 0, Б --- 100, В --- 101, Г --- 110 и Д --- 111.

Поскольку ни один из полученных кодов не является префиксом другого, они могут быть однозначно декодированы при чтении их из потока. Кроме того, наиболее частый символ сообщения А закодирован наименьшим количеством бит, а наиболее редкий символ Д --- наибольшим.

При этом общая длина сообщения, состоящего из приведенных в таблице символов, составит 87 бит (в среднем 2.2308 бита на символ). 
При использовании равномерного кодирования общая длина сообщения составила бы 117 бит (ровно 3 бита на символ). 
Энтропия источника, независимым образом порождающего символы с указанными частотностями, составляет ~2.1858 бита на символ, то есть избыточность построенного для такого источника кода Хаффмана, понимаемая как отличие среднего числа бит на символ от энтропии, составляет менее 0.05 бита на символ.

\chapter{Требования к входным данным}

Программа принимает три аргумента командной строки.
\begin{enumerate}
\item Первый аргумент --- опция (-c для сжатия и -d для декомпрессии).
\item Второй аргумент --- путь к файлу, который необходимо сжать/восстановить.
\item Третий аргумент --- путь к сжатому/восстановленному файлу.
\end{enumerate}

При наличии ошибок в аргументах командной строки или при передаче на вход программе пустого файла программа выдаст сообщение об ошибке и завершится.

Программное обеспечение для сжатия и восстановления файлов с помощью алгоритма Хаффмана было написано на языке программирования C.

Программа может сжимать/восстанавливать файлы любых типов.

Ограничение: алгоритм сжатия не будет работать в случае, если сжимаемый файл состоит из одного и того же символа. 
Для корректной работы алгоритма в файле должно быть хотя бы два разных символа.

\chapter{Тестирование программного обеспечения}

В таблице~\ref{tabular:tests} приведены тесты для проверки корректности работы реализованного программного обеспечения.

\begin{table}[H]
\caption{Тесты}
\label{tabular:tests}
\begin{tabular}{|p{4cm}|p{5cm}|p{6cm}|}
\hline
\textbf{Описание} & \textbf{Размер исходного файла, Б} & \textbf{Размер сжатого файла, Б}
\tabularnewline
\hline
Пустой входной файл & 0 & Error: input file is empty.
\tabularnewline
\hline
Кол-во аргументов командной строки не равно трем & 0 & Error: program requires 3 parameters.
\tabularnewline
\hline
Первый аргумент неправильный & 0 & Error: incorrect option.
\tabularnewline
\hline
Рисунок формата JPG (небо) & 5127 & 5054
\tabularnewline
\hline
Рисунок формата PNG (красный прямоугольник) & 6958 & 2320
\tabularnewline
\hline
Архив формата RAR & 216 & 156
\tabularnewline
\hline
\end{tabular}
\end{table}

Все тесты пройдены успешно.

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения данной лабораторной работы был реализован алгоритм Хаффмана для сжатия данных.

Были выполнены следующие задачи:
\begin{enumerate}
\item[1)] изучен принцип работы алгоритма Хаффмана;
\item[2)] разработано программное обеспечение для сжатия и восстановления файлов с помощью алгоритма Хаффмана;
\item[3)] протестировано разработанное программное обеспечение.
\end{enumerate}

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ,heading=bibintoc]}

\end{document}
